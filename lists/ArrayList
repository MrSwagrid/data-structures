import java.util.Iterator;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;

@SuppressWarnings("serial")
public class ArrayList<T> implements List<T> {
	
	private static final int MIN_CAPACITY = 8;
	
	private static final int EXP_RATE = 2;
	
	private T[] values;
	
	private int size = 0;
	
	@SafeVarargs
	public ArrayList(T... values) {
		this.values = values.clone();
		size = values.length;
		if(size == 0)
			setCapacity(MIN_CAPACITY);
	}
	
	public ArrayList(ArrayList<T> list) {
		values = list.values.clone();
		size = list.size;
	}
	
	public ArrayList(List<T> list) {
		setCapacity(list.size());
		list.forEach(this::add);
	}
	
	public void add(T value) {
		add(size, value);
	}
	
	public void add(int index, T value) {
		if(size >= values.length)
			setCapacity(values.length * EXP_RATE);
		shiftRight(index, size++ - 1, 1);
		values[index] = value;
	}
	
	public void set(int index, T value) {
		if(index != size)
			remove(index);
		add(index, value);
	}
	
	public void addAll(List<T> list) {
		setCapacity(values.length + list.size());
		list.forEach(this::add);
	}
	
	public T get(int index) {
		return values[index];
	}
	
	public void remove(int index) {
		removeRange(index, index);
	}
	
	public void removeIf(Predicate<T> selector) {
		for(int i = 0; i < size;) {
			if(selector.test(values[i]))
				remove(i);
			else
				i++;
		}
	}
	
	public void removeRange(int start, int finish) {
		shiftLeft(finish + 1, size - 1, finish - start + 1);
		size -= (finish - start + 1);
		if(size < values.length / EXP_RATE)
			setCapacity(values.length / EXP_RATE);
	}
	
	public void clear() {
		for(int i = 0; i < values.length; i++)
			values[i] = null;
		size = 0;
	}
	
	public boolean contains(Predicate<T> selector) {
		for(int i = 0; i < size; i++) {
			if(selector.test(values[i]))
				return true;
		}
		return false;
	}
	
	public int indexOf(Predicate<T> selector) {
		for(int i = 0; i < size; i++) {
			if(selector.test(values[i]))
				return i;
		}
		return -1;
	}
	
	public int lastIndexOf(Predicate<T> selector) {
		for(int i = size - 1; i >= 0; i--) {
			if(selector.test(values[i]))
				return i;
		}
		return -1;
	}
	
	public void sort(BiPredicate<T, T> comparator) {
		//TODO
	}
	
	public <U> ArrayList<U> map(Function<T, U> mapper) {
		ArrayList<U> list = new ArrayList<>();
		list.setCapacity(size);
		for(T value : this)
			list.add(mapper.apply(value));
		return list;
	}
	
	public void replace(UnaryOperator<T> mapper) {
		ArrayList<T> list = map(mapper);
		values = list.values;
		size = list.size;
	}
	
	public ArrayList<T> subList(int start, int finish) {
		ArrayList<T> list = new ArrayList<>();
		list.setCapacity(finish - start + 1);
		for(int i = start; i <= finish; i++)
			list.add(values[i]);
		return list;
	}
	
	public int size() { return size; }
	
	public boolean isEmpty() { return size == 0; }
	
	@SuppressWarnings("unchecked")
	private void setCapacity(int capacity) {
		if(capacity == values.length) return;
		T[] v = (T[]) new Object[Math.max(capacity, MIN_CAPACITY)];
		for(int i = 0; i < Math.min(values.length, v.length); i++) {
			v[i] = values[i];
		}
		values = v;
	}
	
	private void shiftLeft(int left, int right, int amount) {
		if(left > right)
			return;
		for(int i = left; i <= right; i++) {
			values[i - amount] = values[i];
		}
	}
	
	private void shiftRight(int left, int right, int amount) {
		if(left > right)
			return;
		for(int i = right; i >= left; i--) {
			values[i + amount] = values[i];
		}
	}
	
	public ArrayList<T> clone() {
		return new ArrayList<T>(values);
	}
	
	@Override
	public Iterator<T> iterator() {
		return new ListIterator();
	}
	
	@Override
	public String toString() {
		String str = "{";
		for(int i = 0; i < size; i++) {
			str += values[i];
			if(i < size - 1)
				str += ", ";
		}
		return str + "}";
	}
	
	@Override
	public boolean equals(Object o) {
		if(!(o instanceof List))
			return false;
		List<?> l = (List<?>) o;
		if(size != l.size())
			return false;
		for(int i = 0; i < size; i++) {
			if(!values[i].equals(l.get(i)))
				return false;
		}
		return true;
	}
	
	private class ListIterator implements Iterator<T> {
		
		private int index = 0;

		@Override
		public boolean hasNext() {
			return index < size;
		}

		@Override
		public T next() {
			return values[index++];
		}
		
		@Override
		public void remove() {
			ArrayList.this.remove(--index);
		}
	}
}
